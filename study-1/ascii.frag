// ========================================
// ASCII効果用フラグメントシェーダー
// パーティクルを描画したテクスチャをASCII文字風に変換
// bitnb.io風のレトロなASCIIアート効果を実現
// ========================================

// 浮動小数点の精度を中精度に設定
precision mediump float;

// Uniform変数: JavaScriptから渡される値
uniform vec2 uResolution;      // 画面解像度 (width, height)
uniform vec2 uTextureSize;     // テクスチャのサイズ（現在未使用）
uniform sampler2D uTexture;    // パーティクルを描画したテクスチャ
uniform sampler2D uAsciiMap;   // ASCII文字が並んだテクスチャ
uniform float uAsciiColorStep; // 色の段階化の強さ（ポスタライズ効果）
uniform float uTileSize;       // 1つのASCII文字のサイズ（ピクセル）
uniform float uTileStrength;   // 文字の明るさの強さ
uniform int uBioMode;          // Bio Mode（緑色モード）のオン/オフ

// Varying変数: 頂点シェーダーから受け取る値
varying vec2 vUv;              // UV座標（0.0 ~ 1.0）

void main() {
  // ========================================
  // 1. タイルの分割数とローカル座標の計算
  // ========================================
  // 画面をタイルに分割した時の、タイルの数を計算
  // 例: 解像度1000x800, タイルサイズ10 → タイル数100x80
  vec2 tileCount = floor(uResolution / uTileSize);

  // 現在のピクセルがどのタイル内のどの位置にあるか（0.0 ~ 1.0）
  // fract() は小数部分を取り出す関数
  // 例: vUv * tileCount = 2.3 → fract(2.3) = 0.3
  vec2 tileUv = fract(vUv * tileCount);

  // 現在のピクセルがどのタイルに属しているか（タイルのID）
  // 例: vUv * tileCount = 2.3 → floor(2.3) = 2.0
  vec2 tileId = floor(vUv * tileCount);

  // ========================================
  // 2. タイルの中心座標を計算
  // ========================================
  // 各タイルの中心のUV座標を計算
  // (tileId + 0.5) で中心を取得し、tileCount で割って正規化
  // この中心位置の色を使ってタイル全体の文字を決定
  vec2 tileCenter = (tileId + 0.5) / tileCount;

  // ========================================
  // 3. 元のテクスチャから色をサンプリング
  // ========================================
  // パーティクルを描画したテクスチャから、タイル中心の色を取得
  vec4 texColor = texture2D(uTexture, tileCenter);

  // ========================================
  // 4. 輝度の計算（明るさ）
  // ========================================
  // RGB値から輝度（明るさ）を計算
  // 人間の目の感度に基づいた係数を使用:
  //   赤: 0.299, 緑: 0.587, 青: 0.114
  // dot() は内積を計算する関数（ベクトル同士の掛け算と足し算）
  // 結果: 0.0（暗い）~ 1.0（明るい）
  float luminance = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));

  // ========================================
  // 5. ASCII文字のインデックスを決定
  // ========================================
  // 輝度を10段階に分ける（0.0, 0.1, 0.2, ... 0.9）
  // 暗い: 0.0（スペース）、明るい: 0.9（@記号）
  // floor() で切り捨て、10.0で割ることで段階化
  float charIndex = floor(luminance * 10.0) / 10.0;

  // ========================================
  // 6. ASCII文字マップからサンプリング
  // ========================================
  // ASCII文字テクスチャのUV座標を計算
  // X座標: charIndex（どの文字を使うか）
  // Y座標: 0.5（文字の中央の高さ）
  vec2 asciiUv = vec2(charIndex, 0.5);

  // タイル内の位置に応じて文字のどの部分を表示するか決定
  // tileUv.x は 0.0 ~ 1.0 の範囲なので、10.0で割ることで
  // 1文字分の幅（0.1）の範囲内に収める
  asciiUv.x += tileUv.x / 10.0;

  // ASCII文字マップテクスチャから文字のピクセル色を取得
  vec4 asciiChar = texture2D(uAsciiMap, asciiUv);

  // ========================================
  // 7. 文字の明るさを調整
  // ========================================
  // asciiChar.r は文字のピクセルの明るさ（白い部分: 1.0, 黒い部分: 0.0）
  // uTileStrength で文字の濃さを調整
  float charBrightness = asciiChar.r * uTileStrength;

  // ========================================
  // 8. 色のステップ化（ポスタライズ効果）
  // ========================================
  // 色を段階的にすることでレトロな見た目にする
  // 例: uAsciiColorStep = 0.1 の場合
  //     0.23 → floor(0.23 / 0.1) * 0.1 = 2.0 * 0.1 = 0.2
  //     色が段階的になる（0.0, 0.1, 0.2, 0.3...）
  vec3 steppedColor = floor(texColor.rgb / uAsciiColorStep) * uAsciiColorStep;

  // ========================================
  // 9. Bio Mode（緑色モード）の適用
  // ========================================
  // Bio Modeがオンの場合、緑チャンネルだけを残す
  // マトリックス風の緑色の端末表示を再現
  if (uBioMode == 1) {
    steppedColor = vec3(0.0, steppedColor.g, 0.0);
  }

  // ========================================
  // 10. 最終的な色の計算
  // ========================================
  // ステップ化された色 × 文字の明るさ
  // 文字の白い部分（charBrightness が大きい）は明るく表示
  // 文字の黒い部分（charBrightness が小さい）は暗く表示
  vec3 finalColor = steppedColor * charBrightness;

  // ========================================
  // 11. 最終的なピクセル色を出力
  // ========================================
  // アルファ値は常に1.0（完全不透明）
  gl_FragColor = vec4(finalColor, 1.0);

  // 【処理の流れまとめ】
  // 1. 画面をタイルに分割
  // 2. 各タイルの中心の色と明るさを取得
  // 3. 明るさに応じたASCII文字を選択
  // 4. 色をステップ化してレトロな見た目に
  // 5. 文字のパターンと色を組み合わせて表示
}
